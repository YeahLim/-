# 루돌프의 반란

## :timer_clock: **time**

2시간 8분 14초

## :pushpin: **Algorithm**

BFS, 재귀

## :round_pushpin: **Logic**

### 1. 문제 해석
  규칙)
  1. N <= 50, P<=30

  모든 산타마다 완전탐색을 실행해도 시간 복잡도가 30*50 이기 때문에 시간은 충분하다.
  
  요구사항대로 구현을 하면 되는 문제
 
### 2. 알고리즘
***루돌프의 움직임(BFS)***

루돌프는 8방향을 움직이고 이동 우선순위는 다음과 같다.
```
이동 우선순위)
가장 가까운 산타 > 가장 행이 큰 산타 > 가장 열이 큰 산타
```
여기서 비교하는 값은 **거리, 행, 열** 3가지 이므로 해당 속성을 가지고 있는 객체를 만들어 비교해 가장 우선순위가 높은 산타를 찾으면 된다.

가장 가까운 산타를 찾았으면 8방향으로 움직인다.

우선순위는 **산타와 루돌프 간의 거리** 밖에 없으므로 거리 속성 1개를 이용해서 우선순위가 가장 높은 것을 찾는다.

***산타의 움직임(BFS)***

산타는 4방향을 움직이고 이동 우선순위는 다음과 같다.
```
이동 우선순위)
가장 짧은 거리 > 상 > 우 > 하 > 좌
```
여기서 비교하는 값은 **거리, 이동방향** 2가지 이므로 해당 속성을 가지고 있는 객체를 만들어 비교해 가장 우선순위가 높은 산타를 찾으면 된다.

가장 가까운 산타를 찾았으면 해당 좌표로 움직인다.

***상호 작용(재귀)***

산타가 날라가면 좌표가 변경되는데 이때 로직의 흐름은 다음과 같다

1. 산타가 해당 위치로 이동함
2. 기존 위치에 있던 산타가 이전 이동방향으로 이동함

1,2가 산타가 없을 때 까지 반복하므로 재귀로 해결했다.


## :black_nib: **Review**
1. 반복되는 행동이 있으면 재귀로 표현하자
2. 역방향배열을 따로 만들면 역방향을 표현하기 쉽다.
3. Comparable을 사용하는 것 보다 그때 그때 Comparator를 사용하는 것아 코드 속도가 빠를 때도 있다.
