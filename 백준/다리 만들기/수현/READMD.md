# 다리 만들기

## :timer_clock: **time**

50분

## :pushpin: **Algorithm**

BFS

## :round_pushpin: **Logic**

### 1. 문제 해석
  규칙)
  1. 섬 = 동서남북으로 육지가 붙어있는 덩어리
  2. 서로 다른 섬 끼리 다리를 놓으려고 함.
  3. 가장 짧은 다리 = 다리가 격자에서 차지하는 칸의 수가 가장 작은 다리

  **서로 다른 섬**끼리 놓을 **다리**를 구하는 문제이기 때문에 섬을 나누는 로직과 다리를 세우는 로직 2개가 필요하다. 
### 2. 알고리즘
***BFS***

영역을 나누는 로직은 BFS과 DFS 2가지가 있는데 DFS로 진행할 시 최대 N이 100이므로 100개의 메소드가 스택에 쌓여 스택 오버 플로우를 일으킬 수 있다.

이를 방지하기 위해 **BFS를 선택**하였다.

다리를 놓는 로직 또한 같은 이유로 BFS를 이용했다.

현재 최소다리의 길이보다 긴 다리인 경우는 더이상 탐색할 필요가 없으므로 거리를 따져 가지치기를 진행했다.

### 3. 전체 로직
  ```
public class Main {
	static int[] x이동 = {-1,1,0,0};
	static int[] y이동 = {0,0,-1,1};

	static int 바다 = 0;

	public static void main(String[] args){
		섬 구분()
		
		최소 다리 길이 탐색()
	}

	public static void printArr(int[][] map){
		for(int i=0;i< map.length;i++){
			for(int j=0;j<map[i].length;j++){
				System.out.print(map[i][j]+" ");
			}
			System.out.println();
		}
	}
	최소 다리 길이 탐색(맵){
  	for(맵 좌표){
  
      좌표가 바다인 경우 패스

      다리좌표가 들어있는 큐 생성 및 최초 좌표 넣기

      //도착하는 모든 섬에게 섬 이름 부여
      while(다리 좌표가 비어있을 때 까지){
        현재 다리 객체 꺼내기

        현재 다리 길이가 최소 길이보다 같거나 큰경우 탐색 불필요

        방문처리

        for(4방향 탐색){
          1. 맵 밖으로 나간 경우 제거
          2. 이미 방문한 경우 제거
          3. 출발지 섬인 경우 제거          
          4. 다른 섬에 도착한 경우 최소 다리 길이 갱신

          방문처리

          다음 다리 좌표 저장
			}
		}


		return 최소길이;
	}
	
	섬 구분(맵){
		섬 이름을 1부터 시작
		
		//섬 구분하기
		for(모든 섬 좌표 탐색){
				방문처리
				바다인 경우 섬이 아니므로 탐색 불필요
        섬 좌표 큐 생성 및 초기 좌표 저장

				while(섬좌표가 빌때 까지){
					현재 좌표 꺼내기
					방문 처리
          섬 이름 지정

					//4방향 탐색
					for(4방향 탐색){
						맵 밖으로 나간 경우 제거
						이미 방문한 경우 제거
						바다인 경우 제거
						
						현재 위치를 섬으로 지정 및 방문처리

						다음 좌표를 큐에 저장
					}
				}
				
				다음 섬 이름 변화
		}

		return 나누어질 섬 좌표 맵;
	}
	
	맵 밖에 나가는지 판단(좌표, 맵){
		좌표 밖에 나가면 true 리턴

    아니면 false 리턴
	}
}
class 좌표{
	int 행;
	int 열;
}
class 다리 extends 좌표{
	int 다리길이
}
  ```

## :black_nib: **Review**
