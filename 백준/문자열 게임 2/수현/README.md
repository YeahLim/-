# 문자열 게임 2

## :timer_clock: **time**

50분

## :pushpin: **Algorithm**

문자열, 맵

## :round_pushpin: **Logic**

### 1. 알고리즘
   
  ***문제 해석***
  
  규칙)
  1. 알파벳 소문자로 이루어진 문자열 W가 주어진다.
     
      => 소문자 밖에 없으므로 대/소문자 구별 X
  
  2. 양의 정수 K가 주어진다.
  
     => K = (같은 알파벳이 넘지도, 부족하지도 않게 딱 포함 되어야 하는 개수)
     
  3. 어떤 문자를 정확히 K개를 포함하는 가장 짧은 연속 문자열의 길이를 구한다.
  
     => 아무 알파벳이 딱 K개 있는 부분문자열 중 최소 길이
     
  4. 어떤 문자를 정확히 K개를 포함하고, 문자열의 첫 번째와 마지막 글자가 해당 문자로 같은 가장 긴 연속 문자열의 길이를 구한다.
  
     => 아무 알파벳이 딱 K개 있고 맨 앞과 맨 뒤의 알파벳이 같은 부분문자열 중 최대 길이

  이때 3번 조건을 만족하려면 **앞 뒤가 똑같은 알파벳**이어야 하므로 **4번 조건을 만족하는 문자열 중 최소 길이가 3번 조건을 만족**한다. 
  그러므로 4번 조건만 탐색하여 최소길이와 최대길이를 구하면 해결된다.
  
  EX) 
  ```
   K = 2, str = absbgdfb
   K = 2를 만족하는 문자열 = bsb, absb, bsbg, bgdfb, sbgdfb
   3번 조건 = bsb
   4번 조건 = bgbfb
  ```

***맵***

4번 조건을 만족하는 문자열은 (알파벳이 처음 등장한 인덱스)~(K번째로 알파벳이 인덱스) 이다.

그러므로 알파벳 별로 처음 등장한 순서로 인덱스를 저장하고 K 길이 만큼 

  
3. 전체 로직
  ```
    main{
      재귀를 통한 트리 생성

      트리를 이용해 전위/후위 순회
    }

    트리 생성(남은 노드 리스트, 부모 노드){
      남은 리스트 노드가 1개 이하면(현재 부모 노드도 포함되어 있으므로) 더이상 탐색 X

      for(2번째 노드 ~ 끝까지){
        if(부모 x값보다 현재 x값이 작으면){
            왼쪽 노드 리스트에 추가
        }
        if(부모 x값보다 현재 x값이 크면){
            오른쪽 노드 리스트에 추가
        }
      }

      if(왼쪽 노드 리스트가 있으면){
        현재 부모 노드에 왼쪽 노드 등록
        왼쪽 노드 목록으로 트리 생성
      }
      if(오른쪽 노드 리스트가 있으면){
        현재 부모 노드에 오른쪽 노드 등록
        오른쪽 노드 목록으로 트리 생성
      }
   }

    순회(현재 노드){
      전위 순회 목록에 현재 노드 등록
      왼쪽 노드 순회
      오른쪽 노드 순회
      후위 순회 목록에 현재 노드 등록
    }
  ```

## :black_nib: **Review**

1. input값이 정사각형의 배열이 아닌 삼각형 형태로 배열을 주기 때문에 length 변수가 아닌 triangle[i].length로도 가능
