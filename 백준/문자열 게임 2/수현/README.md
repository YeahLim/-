# 문자열 게임 2

## :timer_clock: **time**

50분

## :pushpin: **Algorithm**

문자열, 맵

## :round_pushpin: **Logic**

### 1. 문제 해석
  규칙)
  1. 알파벳 소문자로 이루어진 문자열 W가 주어진다.
     
      => 소문자 밖에 없으므로 대/소문자 구별 X
  
  2. 양의 정수 K가 주어진다.
  
     => K = (같은 알파벳이 넘지도, 부족하지도 않게 딱 포함 되어야 하는 개수)
     
  3. 어떤 문자를 정확히 K개를 포함하는 가장 짧은 연속 문자열의 길이를 구한다.
  
     => 아무 알파벳이 딱 K개 있는 부분문자열 중 최소 길이
     
  4. 어떤 문자를 정확히 K개를 포함하고, 문자열의 첫 번째와 마지막 글자가 해당 문자로 같은 가장 긴 연속 문자열의 길이를 구한다.
  
     => 아무 알파벳이 딱 K개 있고 맨 앞과 맨 뒤의 알파벳이 같은 부분문자열 중 최대 길이

  이때 3번 조건을 만족하려면 **앞 뒤가 똑같은 알파벳**이어야 하므로 **4번 조건을 만족하는 문자열 중 최소 길이가 3번 조건을 만족**한다. 
  그러므로 4번 조건만 탐색하여 최소길이와 최대길이를 구하면 해결된다.
  
  EX) 
  ```
   K = 2, str = absbgdfb
   K = 2를 만족하는 문자열 = bsb, absb, bsbg, bgdfb, sbgdfb
   3번 조건 = bsb
   4번 조건 = bgbfb
  ```

### 2. 알고리즘
***맵***

4번 조건을 만족하는 문자열은 (알파벳이 처음 등장한 인덱스)~(K번째로 알파벳이 인덱스) 이다.

그러므로 알파벳 별로 처음 등장한 순서로 인덱스를 저장하고 K 길이 만큼 뒤에 있는 인덱스까지의 길이를 구하면 3번과 4번 조건을 만족하는 문자열의 길이를 구할 수 있다.

알파벳마다 인덱스를 저장하고 알파벳 별로 인덱스에 접근하기 위해 key를 알파벳, value를 인덱스 리스트를 가지는 맵을 이용했다.

### 3. 전체 로직
  ```
      Map<알파벳, 인덱스 리스트> 알파벳_인덱스 맵= new HashMap<>();

      for(인덱스 : 문자열){
         알파벳 마다 인덱스를 저장
      }      
      
      for(알파벳 : 알파벳_인덱스 맵){
         인덱스 리스트 = 알파벳_인덱스맵.get(알파벳)

         for(현제 인덱스 + K길이 뒤의 인덱스가 존재할때 까지){
            현재 길이 = K길이 뒤의 인덱스 - 현재 인덱스
            최소 길이 = min(최소 길이,현재 길이)
            최대 길이 = max(최대 길이,현재 길이)
         }
      }

      최소길이가 없으면 최대 길이도 없으므로 -1 출력
      아니라면 최소 길이와 최대길이 출력
  ```

## :black_nib: **Review**
