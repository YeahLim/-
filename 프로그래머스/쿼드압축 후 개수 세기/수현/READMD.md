# 쿼드압축 후 개수 세기

## :timer_clock: **time**

28분 41초

## :pushpin: **Algorithm**

분할 정복, 재귀

## :round_pushpin: **Logic**

### 1. 문제 해석
  규칙)
  1. 당신이 압축하고자 하는 특정 영역을 S라고 정의합니다.
  2. 만약 S 내부에 있는 모든 수가 같은 값이라면, S를 해당 수 하나로 압축시킵니다.
  3. 그렇지 않다면, S를 정확히 4개의 균일한 정사각형 영역(입출력 예를 참고해주시기 바랍니다.)으로 쪼갠 뒤, 각 정사각형 영역에 대해 같은 방식의 압축을 시도합니다.

  3번을 진행하면 1번으로 돌아가서 다시 규칙을 실행한다. **똑같은 로직을 다시 실행하므로 재귀를 이용**한다. 
  
  크기가 최대 1024(=2^10)이고 4개씩 분할되므로 최대 경우의 수는 4^10 = 2^20 이기 때문에 재귀를 이용해서 1억 보다 작아 1초안에 해결이 가능하다.
 
### 2. 알고리즘
***재귀***

영역은 길이가 n인 정사각형에서 각 길이가 n/2인 좌상단, 우상단, 좌하단, 우하단 4개의 정사각형으로 나뉘어진다. 

이때 나뉘어진 **좌상단 값**과 나뉘어진 정사각형의 **길이**를 알고 있다면 기존의 배열을 그대로 사용해도 원하는 영역만큼 순회가 가능하다.

### 3. 전체 로직
  ```
class Solution {
    int[] 0과1의 쿼드압축한 개수 = new int[2];
    
    public int[] solution(int[][] arr) {
        좌상단 좌표 = (0,0)
        
        쿼드 압축 실행((0,0), 최초 길이, arr)
        
        return 0과1의 쿼드압축한 개수;
    }
    
    public void 쿼드압축(현재 좌상단, 현재 사각형의 길이, arr){
        0과 1의 전체 개수 = new int[2];
        
        범위 내의 0,1 개수 세기
  
        if(모든 칸이 1인 경우){
          1의 쿼드압축한 개수 증가
        }

        if(모든 칸이 0인 경우){
          0의 쿼드압축한 개수 증가
        }
        
        if(0과 1이 섞여 있는경우){
            다음 길이 = 현재 길이 / 2
            
            좌상단 쿼드압축
            우상단 쿼드압축
            좌하단 쿼드압축
            우하단 쿼드압축
        }
    }
}

좌표{
  int 행
  int 열
}
  ```

## :black_nib: **Review**
