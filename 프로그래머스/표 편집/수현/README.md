# 쿼드압축 후 개수 세기

## :timer_clock: **time**

1시간 49분 18초

## :pushpin: **Algorithm**

더블 링크드 리스트

## :round_pushpin: **Logic**
 
### 1. 알고리즘
***더블링크드리스트***

  배열리스트로 구현)
    O(n) = (인덱스 탐색 시간)*(삭제,복구 시간)*(명령어 개수) = 1 * 1,000,000 * 200,000
    링크드리스트로 구현)
    O(n) = (인덱스 탐색 시간)*(삭제,복구 시간)*(명령어 개수) = 1,000,000 * 1 * 200,000
    
    삭제, 복구, 인덱스 탐색을 전부 O(1)로 해야 최대 200,000명령어 이내로 끝낼 수 있다.
    이때 탐색을 배열로, 삭제 복구도 배열로 구현하면 전부 O(1)로 가능하다
    
    이를 구현하기 위해 다음 인덱스 배열과 이전 인덱스 배열을 이용해 삭제와 복구를 구현하고
    해당 배열들의 인덱스를 이용해 탐색하게 했다.
    
    삭제) 
    이전 -> 현재 -> 다음 
    이전 -> 다음
    
    다음[이전] = 다음
    이전[다음] = 이전
    
    복구) 
    이전 -> 다음
    이전 -> 현재 -> 다음 
    
    다음[이전] = 현재
    이전[다음] = 현재
    
    이때 다음과 이전이 맨 끝인경우 outofindex에러가 발생하므로 예외처리를 한다.

### 2. 전체 로직
  ```java
class Solution {
    int [] prev;
    int [] next;
    Stack<Integer> history;
    int END = -1;
    
    public String solution(int n, int k, String[] cmd) {        
        각 인덱스 별 이전 인덱스 저장 배열 초기화
        각 인덱스 별 다음 인덱스 저장 배열 초기화
        
        for(모든 명령어){
            if(삭제){
                삭제 인덱스 저장
                삭제
                다음 커서
            }else if(복구){
                가장 최근 삭제된 인덱스 꺼내기
                복구
            }else if(아래 이동){
                아래로 이동
            }else if(c.charAt(0)=='U'){
                위 이동
            }
        }
  
        삭제된 인덱스 방문처리
        
        문자열 생성
        
        return 정답;
    }
}
  ```

## :black_nib: **Review**

더블 링크드 리스트에서 삭제된 것을 다시 붙이려면 삭제된것을 그냥 저장해놓으면 된다.
